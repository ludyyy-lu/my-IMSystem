## 项目整体目录结构
    ✅ 采用 go-zero + 微服务架构
    ✅ 每个服务为独立 go-zero 工程
    ✅ 服务之间使用 gRPC 通信，统一入口由 API Gateway 提供 HTTP 接口
    ✅ 支持 Docker Compose 一键部署（包含 Kafka / Redis / MySQL / Etcd）

```   
im-backend/
├── api-gateway/               # go-zero API 接口网关（对外 HTTP）
│   └── etc/                   # 配置文件
│
├── ws-gateway/                # WebSocket 长连接网关（独立服务）
│   └── etc/
│
├── user-service/              # 用户注册 / 登录 / 信息查询
│   └── etc/
│
├── auth-service/              # JWT 签发 / 刷新 / 多端会话管理
│   └── etc/
│
├── friend-service/            # 好友增删 / 验证 / 通知
│   └── etc/
│
├── group-service/             # 群聊管理 / 成员管理 / 群功能控制
│   └── etc/
│
├── chat-service/              # 消息收发、Kafka 消费、离线消息
│   └── etc/
│
├── common/                    # 通用代码包（proto、工具函数、模型等）
│   ├── proto/                 # Protobuf 定义共享目录
│   ├── model/                 # GORM 模型
│   ├── utils/                 # 加密、token、日志等
│
├── deploy/                    # 部署文件夹
│   ├── docker-compose.yaml    # 一键部署入口
│   ├── Dockerfile             # 各服务对应 Dockerfile 示例
│   ├── kafka/                 # Kafka & Zookeeper 配置
│   ├── mysql/                 # 初始化 SQL 文件
│   └── etcd/                  # etcd 注册配置（可选）
│
├── scripts/                   # 启动脚本 / 初始化工具
├── go.mod
├── README.md
```
## 各模块启动前所需依赖项说明
| 模块               | 依赖项                    | 是否必须 | 说明                                |
| ---------------- | ---------------------- | ---- | --------------------------------- |
| `user-service`   | MySQL、Etcd             | ✅ 必须 | MySQL 存用户表，Etcd 注册服务用于 RPC        |
| `auth-service`   | Redis、Etcd             | ✅ 必须 | Redis 存 token/session，Etcd 用于服务发现 |
| `friend-service` | MySQL、Redis、Etcd       | ✅ 必须 | 关系存 MySQL，缓存好友列表用 Redis           |
| `chat-service`   | Kafka、Redis、MySQL、Etcd | ✅ 必须 | 消息生产/消费用 Kafka，Redis 缓存离线消息       |
| `group-service`  | MySQL、Redis、Etcd       | ✅ 必须 | 群聊信息在 MySQL，Etcd 注册 RPC           |
| `ws-gateway`     | Redis、auth-service RPC | ✅ 必须 | 校验用户在线状态 & 鉴权依赖 Redis + auth      |
| `api-gateway`    | 所有其他服务 gRPC 接口、Etcd    | ✅ 必须 | 作为网关必须能路由到各服务                     |
##  推荐环境准备（本地开发）
| 组件     | 推荐方式                    | 补充说明                    |
| ------ | ----------------------- | ----------------------- |
| Go 版本  | Go 1.21+                | 安装 `goctl` 脚手架工具        |
| 数据库    | MySQL 8                 | 本地或容器皆可                 |
| Redis  | Redis 6+                | 用于缓存 token、会话、在线状态      |
| Kafka  | kafka + zookeeper 容器    | 建议用 Docker Compose 一键启动 |
| Etcd   | 3.x 版本                  | 用于服务注册 / 发现             |
| Docker | Docker + Docker Compose | 本地快速启动服务依赖              |

## user-service
| 功能         | 目的                            |
| ---------- | ----------------------------- |
| 注册用户       | 插入新用户数据至 MySQL                |
| 用户登录（密码校验） | 返回 token（后续由 auth-service 实现） |
| 获取用户信息     | 根据 uid 查询用户                   |
| 用户列表/搜索    | 提供搜索或展示功能                     |

我们用 go-zero 提供的工具 goctl 来快速创建**服务骨架**。
编写user.proto，执行
```
goctl rpc protoc common/proto/user/user.proto \
  --go_out=./user-service \
  --go-grpc_out=./user-service \
  --zrpc_out=./user-service
```
go_out: proto生成的go代码所在的目录，proto本身的命令参数
go-grpc_out：proto生成的grpc代码所在的目录，proto本身的命令参数，和go_out必须同一个目录
zrpc_out： goctl rpc自带的命令，go-zero生成的代码所在的目录
执行成功后，user-service 下就会生成：
user.pb.go（自动生成）
user_grpc.pb.go
userrpc.go（注册服务用）
### 阶段总结
| 步骤    | 内容                                              | 是否完成 |
| ----- | ----------------------------------------------- | ---- |
| 🧱 1  | 用 `goctl` 生成了 `user-service` 骨架 ✅               | ✔️   |
| 📦 2  | 编写了 `user.proto` 并用 `goctl rpc protoc` 正确生成代码 ✅ | ✔️   |
| 🛠️ 3 | 配置并运行了 Docker 中的 MySQL 容器 ✅                     | ✔️   |
| 🔗 4  | 用 GORM 成功连接数据库并自动迁移 User 表 ✅                    | ✔️   |
| 🧹 5  | 把数据库配置解耦到了 `yaml` 配置文件 ✅                        | ✔️   |
| 🚀 6  | 成功运行 `user-service` 服务 ✅                        | ✔️   |
其中第一步完全没必要，第二部注意proto文件编写

### 阶段总结
我们已经完成了：
✅ 使用 Go-Zero 构建 user 微服务骨架
✅ 编写并生成 proto 文件（注册 & 查询接口）
✅ 使用 GORM 初始化数据库连接、自动建表
✅ 实现 Register 用户注册逻辑（密码加密 + 写入数据库）
✅ 实现 GetUser 查询逻辑（通过 UID 查用户名）

### 登陆逻辑
| 步骤  | 内容说明                                          |
| --- | --------------------------------------------- |
| 1️⃣ | 查询数据库，检查用户是否存在                                |
| 2️⃣ | 校验密码是否匹配（用 bcrypt 的 `CompareHashAndPassword`） |
| 3️⃣ | 签发 JWT token（这个我们会统一封装好）                      |
| 4️⃣ | 返回 token 给前端或调用方                              |


### 阶段总结
登录生成 JWT；
全局拦截器检查 token；
未携带 token 自动拒绝；
带上合法 token 正常访问
只是写了但是没验证能不能行，不想修改bug（脆弱哽咽

### GetProfile
| 步骤   | 内容                                     | 说明           |
| ---- | -------------------------------------- | ------------ |
| ✅ 1  | 用户发起 `GetProfile` 请求（携带 token）         | 用于鉴权         |
| ✅ 2  | gRPC 拦截器校验 token，将 UID 放入 context      | 已完成          |
| 🧩 3 | 在 `GetProfileLogic` 中，从 context 提取 UID | 不需要客户端传 uid  |
| 🧩 4 | 用 GORM 查库获取用户资料                        | username、头像等 |
| ✅ 5  | 返回给客户端                                 |              |

### 还可以优化的地方
如果你希望在拦截器中就把 UID 放到 context 中，可以自定义 context key，不过目前这个方案更直观
后面我们会为用户增加修改资料接口（nickname、签名、头像上传）
✅ 修改个人资料接口（UpdateProfile）
✅ 新增头像字段、性别、个性签名等（gorm 自动迁移）
✅ 实现前端需要的用户详情接口（多字段 + 安全脱敏）
咳嗨嗨，以后再说吧，这个go-zero把我害惨了

### 阶段总结
| 阶段      | 功能目标                    | 技术点                   |
| ------- | ----------------------- | --------------------- |
| ✅ 当前阶段  | 用户系统（注册 / 登录 / token鉴权） | gRPC、gorm、jwt         |
| 🚧 下阶段  | 好友系统（加好友 / 拉黑 / 列表）     | 多端关系表、状态码设计           |
| 🚧 后续阶段 | IM 通讯模块（消息发送、接收、存储）     | WebSocket、Redis、消息持久化 |
| 🚧 可选   | 用户在线状态、设备管理、消息已读        | 令牌刷新、WS心跳、设备识别        |

### Protobuf 代码的编写逻辑
确定版本：开头声明 syntax = "proto3";（推荐用 proto3）。
配置包名：根据业务模块定义 package（如用户模块用 user，订单模块用 order），并指定生成目标语言代码的路径（如 go_package）。
定义消息（数据结构）：
先想清楚接口需要的 “输入参数” 和 “输出结果”（如注册需要用户名密码，返回用户 ID）。
为每个字段指定类型和唯一编号（编号从 1 开始，不重复）。
定义服务（RPC 接口）：
一个服务对应一个业务模块（如 User 服务处理用户相关操作）。
每个 rpc 方法对应一个具体功能，格式为 rpc 方法名(请求消息) returns (响应消息);。

### 疑问
gRPC拦截器是什么，作用是什么？

---
## auth-service
拆分user-service和auth-service
| 服务               | 职责范围                   |
| ---------------- | ---------------------- |
| **auth-service** | 登录、注册、JWT 生成和校验、密码加密校验 |
| **user-service** | 用户基本资料查询、更新（头像、昵称等）    |

| 项                          | 点评                                                      | 建议                |
| -------------------------- | ------------------------------------------------------- | ----------------- |
| ✅ 用户资料 & 状态放在 user-service | **合理**，这些属于业务 Profile                                   | 保留                |
| ⚠️ 登录注册放在 user-service     | 这是“认证逻辑”，应归属于 auth-service                              | ✔ 拆出去             |
| ⚠️ 多设备会话管理写在 auth-service  | 如果是 “登录态/session/token管理” 就合理；如果是“在线状态”应该在 user/gateway | 具体看实现逻辑           |
| ⚠️ Redis 只放在 auth-service  | 如果 user 也有状态缓存（如在线状态），那 user-service 也应该连 Redis         | 根据实际业务扩展 Redis 使用 |

推荐分工
| 服务               | 职责说明                                                                             | 技术栈                                  |
| ---------------- | -------------------------------------------------------------------------------- | ------------------------------------ |
| **auth-service** | 负责纯认证逻辑：<br>✔ 用户注册（仅注册账号密码）<br>✔ 登录校验密码<br>✔ JWT 签发校验<br>✔ Token刷新、多端 Session 管理 | Redis + JWT + gRPC + bcrypt          |
| **user-service** | 用户资料管理（昵称、头像、个签）<br>用户状态管理（在线、离线）<br>提供好友系统等上层业务                                 | MySQL + GORM + gRPC (+ Redis 如果缓存状态) |


### 编写proto文件
goctl rpc protoc common/proto/auth/auth.proto \
  --go_out=./auth-service \
  --go-grpc_out=./auth-service \
  --zrpc_out=./auth-service \
  --style=go_zero
### 实现token签发
修改jwt.go实现key传入
 !!! 修改过jwt参数之后user-service和ws-service里都有报错，我们以后再修改

### 用户注册
### 用户登录
### 验证Token是否有效

---

## friend-service
### 基础功能
- 发送好友请求
- 查看好友请求列表
- 接受 / 拒绝好友请求
- 查看好友列表
- 删除好友

1. 编写.proto文件
2. 生成friend-service项目框架
```
goctl rpc protoc common/proto/friend/friend.proto \
  --go_out=./friend-service \
  --go-grpc_out=./friend-service \
  --zrpc_out=./friend-service \
  --style=go_zero
```
3. 设计数据库表 (在svc中实现自动迁移，记得修改.yaml文件和config文件中的结构体)
4. 实现发送好友申请的接口逻辑
✅ 实现流程说明
    1. 功能目标
    用户 A 向用户 B 发送好友请求。后续 B 可以选择接受或拒绝。
    2. 步骤拆解
    检查是否已经存在相同的好友请求（避免重复发送）
    检查双方是否已经是好友（避免重复添加）
    插入一条新的好友请求记录（状态为 pending）
5. 查看收到的好友申请 （用户可以查看别人发给自己的所有好友请求。展示请求人信息）
6. 接受/拒绝好友申请
     用户可以接受或拒绝别人发来的好友请求；
     如果接受：更新请求状态为 accepted；在好友表中插入双方为好友的记录（双向关系）；
     如果拒绝：更新请求状态为 rejected；
     重复处理请求时不重复插入数据；
7. 获取好友列表 - 给定一个用户 ID，查出他的好友列表，返回好友的 ID 和用户名
8. 删除好友

### 扩展功能
- 好友事件推送
① 加一个 取消拉黑（Unblock） 功能
→ RPC 方法 + 删除 BlockedUser 表对应行
② 加一个 查看我拉黑了谁 的接口
→ 方便前端展示拉黑列表页
③ 优化“加好友”和“聊天”逻辑
→ 在发起加好友或发消息前先判断是否被拉黑
| 场景           | 行为           | 判断点 |
| ------------ | ------------ | --- |
| A 发起加好友请求给 B | 判断 B 有没有拉黑 A | 拒绝  |
| A 给 B 发消息    | 判断 B 有没有拉黑 A | 拒绝  |
chat-service / friend-service 中使用一个统一的 RPC 方法：
friend.IsBlocked(senderID, targetID)
→ 查询是否存在 BlockedUser{UserID: targetID, BlockedID: senderID}
把它集成到加好友 和 发消息前的逻辑中作为拦截校验。

④ 拉黑后 WebSocket 实时推送通知（被拉黑方收到通知）（？？？） （不做这个，感觉不合理）       

#### 好友事件推送
好友请求时 → 推送 NewFriendRequest 消息给对方
接受/拒绝时 → 推送 FriendAccepted 或 FriendRejected
删除好友/拉黑 → 通知所有设备，刷新列表

---

## ws-gateway
🚪 ws-gateway 模块功能拆分
| 功能              | 说明                           |
| --------------- | ---------------------------- |
| 建立 WebSocket 连接 | 基于 token 验证身份后允许建立连接         |
| 用户在线状态管理        | 用户上下线状态在 Redis 中维护           |
| 长连接用户管理         | 基于内存或 Redis 管理连接 ID、用户 ID 映射 |
| 消息收发（直发）        | 接收消息并转发给目标用户（如果在线）           |
| 消息转 Kafka       | 如果对方不在线，消息投递到 Kafka，由后续服务处理  |

| 模块              | 功能目标描述                            |
| --------------- | --------------------------------- |
| 🧩 Gateway 网关服务 | 建立 WebSocket 长连接，支持 JWT 鉴权        |
| 🔐 用户认证         | 每个连接都带上 token，服务端完成 token 校验      |
| 📶 连接管理         | 每个用户可能有多个连接，管理用户连接列表并支持广播         |
| 📥 消息接收         | 接收客户端消息（发送给好友 / 群），转发到消息通道（Kafka） |
| 📤 消息推送         | 从 chat-service 拉取消息并下发到对应连接       |

技术选型建议：
使用 github.com/gorilla/websocket 建立连接
连接管理使用 map[userID][]conn 或 Redis 实现多端支持
消息体使用 JSON，结构统一
消息入库和离线投递交给 chat-service

推进顺序：
1. 初始化 ws-gateway 服务目录结构
2. 实现 WebSocket 连接建立逻辑
3. 集成 JWT 鉴权中间件
4. 构建连接管理器（Connection Manager）
5. 接收并转发消息到 chat-service
6. 接收 chat-service 推送回来的消息，并下发到连接

### 创建API文件
### 生成代码骨架
进入/ws-gateway目录，执行 goctl api go -api ./api/ws.api -dir .
### 实现/ws/connect接口
ws-gateway/internal/handler/connecthandler.go
升级为 WebSocket 连接并校验 Token
✅ 目标：
接收用户请求（token 通过 header 或 query 传）
鉴权 token，解析出 userId
将 HTTP 连接升级为 WebSocket 连接
将连接和 userId 绑定，加入连接管理器（稍后实现）

**当前已完成**
1. 服务骨架搭建
使用 goctl api 生成了 ws-gateway 的服务目录结构，包括 handler、logic、svc 等模块。
成功集成了 Gorilla WebSocket，具备 WebSocket 升级能力。

2. WebSocket 接入点 connectHandler
从 HTTP 请求中获取 token（支持 Header 或 Query 参数）。
使用封装好的 JWT 工具进行 token 验证。
提取出 userId。
成功将 HTTP 请求升级为 WebSocket 连接。

3. 连接交给逻辑层管理
编写了 HandleWebSocketConnection(svcCtx, userId, conn)，启动连接处理逻辑。
已实现心跳机制（定时发送 Ping），避免连接因空闲被断开。

4. 连接管理器（ConnManager）
在 svc.ServiceContext 中添加了全局连接管理器 ConnManager。
为每个 userId 维护对应的 WebSocket 连接，方便后续实现点对点消息转发。
支持添加连接、移除连接、通过 userId 获取连接。


### 搭建连接管理器
🔜 待开发功能列表（WebSocket 核心功能）
| 模块                   | 说明                                                        | 优先级  |
| -------------------- | --------------------------------------------------------- | ---- |
| 🧠 **ReadPump 读协程**  | 不断读取客户端消息，并解析为结构化命令（如发送聊天消息、心跳、加入群聊等）                     | ⭐⭐⭐⭐ |
| 🧠 **WritePump 写协程** | 把服务端发给客户端的消息写入 WebSocket 连接（如接收方收到聊天消息）                   | ⭐⭐⭐  |
| 🧼 **关闭清理**          | 客户端断开连接时，从 `ConnManager` 中移除对应连接，释放资源                     | ⭐⭐⭐⭐ |
| 💬 **消息格式设计**        | 定义统一的数据包结构，比如 `{type: "chat", to: 123, content: "hello"}` | ⭐⭐⭐⭐ |
| 🚀 **点对点消息转发**       | 根据消息目标用户 ID，调用 `ConnManager` 获取目标连接，进行消息转发                | ⭐⭐⭐⭐ |
| 📦 **离线消息队列（可选）**    | 若目标用户不在线，将消息暂存到 Redis/MySQL 等                             | ⭐⭐   |
| 📢 **广播/群聊支持（可选）**   | 给多个用户推送消息，比如群聊/系统通知                                       | ⭐⭐   |
| 🔐 **封禁/黑名单机制（可选）**  | 限制某些用户连接或通信                                               | ⭐    |

### 实现readpump，接受客户端发来的消息
ReadPump 是啥？
我们要在一个 goroutine 中不停监听这个连接的输入（read loop），一旦客户端通过 WebSocket 发来消息，我们就能拿到数据。
我们规定所有客户端发来的消息必须是json格式，例如：
```
{
  "type": "chat",
  "to": 1002,
  "content": "hello"
}
```

### 疑问
为什么要有connect.go和connectlogic.go两个文件？是什么作用？
| 文件名               | 路径               | 用途                                     |
| ----------------- | ---------------- | -------------------------------------- |
| `connectlogic.go` | `internal/logic` | 是 go-zero 框架**自动生成的 REST 接口处理逻辑层**     |
| `connect.go`      | `internal/logic` | 是你自己手动写的 **WebSocket 长连接处理逻辑（非 REST）** |
为什么它们是分开的？
这是因为：
🧩 connectlogic.go（自动生成的）
这是 go-zero 的传统做法，主要用于：
处理 HTTP 请求
从 controller 层接收 req *types.ConnectReq
返回 resp *types.ConnectResp
属于 RESTful API 风格的业务
简单来说，这是给 rest.RegisterHandlers() 绑定的 handler 用的，和传统 HTTP 路由是一套体系。

🔌 connect.go（你自己手动加的）
这个是WebSocket 长连接逻辑的核心处理部分：
没有使用 go-zero 自动生成结构
WebSocket 是一种 状态连接/事件驱动的通信方式
和 HTTP 一请求一响应完全不同
所以要自己实现 HandleWebSocketConnection 等连接生命周期管理函数
它不是给 HTTP handler 用的，而是给升级成功后的连接用的「真正的通信逻辑处理器」。

| 项目           | `connectlogic.go`     | `connect.go`                |
| ------------ | --------------------- | --------------------------- |
| 用于什么         | 处理 HTTP 请求（RESTful）   | 管理 WebSocket 连接生命周期         |
| 谁调用它         | go-zero 自动注册的 HTTP 路由 | 升级 WebSocket 后你自己写的 handler |
| 是否需要 context | ✅ 有 REST context      | ❌ 用不到 context               |
| 是否状态化连接      | ❌ 一次请求一次响应            | ✅ 长连接、心跳、读写                 |
| 文件来源         | `goctl api` 生成        | 手动创建                        |

### 消息分发器
### 离线消息储存器
🎯 目标回顾
👀 如果消息接收方不在线，把消息暂存在内存 map 里。
👋 当用户重新上线，我们检测到他上线后，把消息一条条发给他。
🤝 暂时使用 map[int64][]Message 模拟，后续可无缝切 Redis。

🧱 我们会做三件事：
✅ 1. 创建离线消息管理器 OfflineMsgManager（内存版）
✅ 2. 在 handleChatMessage 中存储离线消息
✅ 3. 在用户上线时，发放离线消息

**✅ 当前阶段目标**
用 Redis 替代内存 map[int64][]Message，实现离线消息存储和投递逻辑，具备以下能力：
🚀 写入离线消息：当接收方用户不在线，消息写入 Redis。
🔁 读取离线消息：用户上线后自动从 Redis 拉取消息并推送。
🧹 删除离线消息：拉取完毕后清空 Redis 中的数据。

🧱 Redis 方案结构规划
我们将离线消息存为 Redis 的 List（列表结构），使用键名格式：
offline:msg:{userId}

### 阶段总结
| 服务名                | ✔ 你的预期设计（架构图）                                                   | 🛠️ 当前进展与结构                                                       | ✅ 是否匹配                                     |
| ------------------ | --------------------------------------------------------------- | ----------------------------------------------------------------- | ------------------------------------------ |
| **user-service**   | 注册 / 登录 / 用户状态查询 <br> `MySQL + gRPC + GORM`                     | ✅ 已实现注册 & 登录 <br>✅ 使用 GORM 操作 MySQL <br>✅ 支持多设备                   | ✅完全匹配                                      |
| **auth-service**   | JWT 鉴权 / 多设备会话 <br> `Redis + JWT + gRPC`                        | ✅ JWT 鉴权已实现，但暂时集成在 `user-service` 中 <br>❗ 多设备会话状态管理尚未单独拆出         | ⚠️**逻辑合理但尚未物理拆分**<br>（后续可抽 auth-service）   |
| **friend-service** | 好友增删查 / 黑名单 / 通知 <br> `MySQL + Redis + gRPC`                    | ✅ 已建立 `friend-service` 独立目录 <br>❗ 功能部分开发                         | ✅结构上已预留，完全对齐                               |
| **chat-service**   | 消息分发 / 存储 / 历史 / 离线缓存 <br> `Kafka + Redis + MySQL`              | ✅ 正在开发消息路由和离线存储 <br>❗ Kafka 和历史记录功能尚未接入 <br>目前混合写在 `ws-gateway` 中 | ⚠️**功能开始实现，但未物理拆出 chat-service**<br>（计划合理） |
| **group-service**  | 群管理 / 群消息 / 群权限 <br> `MySQL + Redis + gRPC`                     | ❌ 尚未开始                                                            | ✅符合后续阶段                                    |
| **ws-gateway**     | WebSocket 升级 / 心跳 / 消息推送 <br> `WebSocket + Redis PubSub + gRPC` | ✅ 完整实现连接升级、鉴权、心跳、消息转发 <br>✅ 用 Redis 做离线缓存                         | ✅完全符合                                      |
| **api-gateway**    | RESTful 统一入口 <br> `go-zero API 网关`                              | ❌ 暂未开发 REST API 层，目前使用 grpc 客户端直接调试                               | ✅计划合理，可最后阶段统一接入                            |

### 后期计划
✅ 先实现功能再物理拆服务（推荐路径）：
| 步骤                                                   | 动作 |
| ---------------------------------------------------- | -- |
| 🎯 继续完善 chat 消息模块（ack、Kafka）                         |    |
| ⏭️ 后续将 chat 的逻辑从 `ws-gateway` 中迁出到独立的 `chat-service` |    |
| 🔐 将 token 校验逻辑从 user-service 中抽离为 auth-service      |    |
| 🚪 最后整合一个统一对外入口：`api-gateway`，暴露 RESTful API         |    |

👇 接下来的任务安排：
1. Kafka 集成基础
✅ 运行 Kafka（使用 Docker Compose）
✅ 配置 topic（如 chat_messages）
✅ 编写 chat-producer（由 ws-gateway 发消息时调用）
✅ 编写 chat-consumer（由 chat-service 消费消息）
2. chat-service 初步结构设计
使用 go-zero 构建一个独立微服务（gRPC）
暂时只实现 SaveMessage 接口，用于消费 Kafka 消息并写入数据库（MySQL）
3. Kafka 与 ws-gateway 对接
在 handleChatMessage 中将消息发送到 Kafka，而不是直接转发给接收者
让 chat-consumer 从 Kafka 读消息，并判断接收方是否在线：
如果在线 → 发到连接池
如果离线 → 存 Redis 离线缓存

修改了docker-compose.yaml文件，因为kafka的端口配置错了T_T
* 创建topic
进入docker执行docker exec -it im-kafka bash
然后执行
kafka-topics.sh --create \
  --topic im-chat-topic \
  --bootstrap-server localhost:9092 \
  --replication-factor 1 \
  --partitions 3
输出
Created topic im-chat-topic.
表示创建成功

* 完善producer文件
* 在svcCtx中初始化Kafaka Producer
* 修改handleChatMessage，将消息发送到Kafka
    现有的handleChatMessage 是直接发给用户，或者缓存为离线消息。
    我们现在要修改为：
    ✅ 不直接发送；
    ✅ 将消息丢给 Kafka，由后面的 chat-service 来处理。

✅ 补充说明：为什么我们不在 ws-gateway 里直接发消息了？
因为我们现在已经转向微服务解耦架构：
ws-gateway 只负责连接 & 接收消息，发消息的逻辑放在 chat-service 中。
Kafka 作为消息总线，它让系统能更容易水平扩展、失败重试、服务降级。
这样做有几个好处：
| 优点   | 说明                                     |
| ---- | -------------------------------------- |
| 解耦   | ws-gateway 和 chat-service 分开，可以单独部署、扩容 |
| 可追踪  | 所有消息都进 Kafka，有日志可查                     |
| 可持久化 | chat-service 处理时可以顺带入库                 |
| 可扩展  | 可以轻松接入新服务，如群聊、AI 助手、敏感词过滤等             |

--- 

## chat-service
✅ 聊天服务设计内容
我们定义以下 3 个主要 RPC 接口（未来可拓展）：
| 功能        | 方法名                 | 参数结构          |
| --------- | ------------------- | ------------- |
| 1. 发送消息   | `SendMessage`       | 发送方、接收方、消息内容等 |
| 2. 获取聊天记录 | `GetChatHistory`    | 查询两人的聊天记录     |
| 3. 消息状态更新 | `AckMessage`（确认已读等） | ack 某条消息      |

goctl rpc protoc common/proto/chat/message.proto \
  --go_out=./chat-service \
  --go-grpc_out=./chat-service \
  --zrpc_out=./chat-service \
  --style=go_zero

✅ 目标：实现 SendMessage 接口逻辑
这步的重点是：
接收消息（SendMessageReq）
把消息打进 Kafka，异步投递
生成消息 ID、时间戳，返回给前端

定义kafkaproducer工具
在svccontx中初始化producer
完善sendmessagelogic

kafka消费者逻辑
我们的目标是：
从 topic 中消费消息 → 解析后处理：
判断接收方是否在线（查 Redis）
如果在线 → 调用 ws-gateway 的推送接口（gRPC）
如果离线 → 存入 Redis 离线消息列表

定义消息结构
写kafka消费逻辑
在serviceContext里调用它


想清楚以后这个 handler 要干嘛
你接下来可以慢慢往 handler 中加以下功能：
| 功能        | 使用位置                       | 技术组件              |
| --------- | -------------------------- | ----------------- |
| 聊天消息入库    | `INSERT INTO messages ...` | GORM + MySQL      |
| 存储离线消息    | `rdb.RPush(userID, msg)`   | Redis             |
| 发送 ack 确认 | `gRPC` / `WebSocket 推送`    | WebSocket Gateway |
| 检查是否在线    | `Redis.Set(user_status)`   | Redis Pub/Sub     |


### 消息落库
在 chat-service 里，每当 Kafka 收到一条消息（由 ws-gateway 发出），就把它解析成 model.Message，然后写入数据库。
✅ 第一步：在 model 包中添加数据库操作函数

### 下一步计划
 功能名称：聊天记录查询接口（拉历史消息）
 这是用户打开聊天窗口时必须用到的功能，所以是你简历项目中的重点之一。

 第一步：在 model/message.go 中添加 GetChatMessages，这个查询是双向的：我发给你 or 你发给我，属于同一段对话。
 第二步：实现 logic/get_chat_history_logic.go


### 下一步计划
| 阶段     | 内容                                  | 时间预估       |
| ------ | ----------------------------------- | ---------- |
| ✅ 阶段 1 | 聊天消息落库 + Kafka 消费                   | 已完成        |
| ⏳ 阶段 2 | 聊天记录查询接口（GetChatHistory）            | 就差最后两步，1小时 |
| ⏳ 阶段 3 | 写 ack 状态更新（AckMessage）              | 2 小接口，半天   |
| ⏳ 阶段 4 | ws-gateway 收到 ack → 调用 chat-service | 半天         |
| ⏳ 阶段 5 | 整理 README 和运行文档                     | 轻松收尾，一天    |


### 待扩展
实现未读消息数接口（GetUnreadCount）
这个接口用来在打开聊天列表时显示红点，提示用户“你有几条未读消息”。

### 阶段总结
| 模块                 | 现状                            | 需要改进/完善的地方                                         |
| ------------------ | ----------------------------- | -------------------------------------------------- |
| **user-service**   | 实现了用户注册、登录、资料管理基础功能           | 和 auth-service 耦合，缺少清晰边界<br>用户资料设计可更丰富（头像、昵称等）     |
| **auth-service**   | 基本实现了 JWT 认证、Token 签发、刷新功能    | 还没完全独立，未来支持多设备管理、在线状态维护<br>Redis 缓存可优化，安全策略需加强     |
| **friend-service** | 初步完成好友添加、删除等功能                | 拉黑、好友验证逻辑待完善<br>通知推送机制需落地<br>数据库索引和性能优化            |
| **chat-service**   | 完成消息存储、Kafka 消费、离线消息缓存        | 消息幂等、重试、延迟处理等机制待完善<br>群聊消息支持尚未做<br>Redis 缓存设计需更标准化 |
| **ws-gateway**     | 实现了 WebSocket 长连接管理、心跳检测、消息分发 | 连接池需支持分布式<br>Ack 处理和消息路由优化<br>安全和异常处理增强            |
| **group-service**  | 尚未开始开发                        | 群聊创建、成员管理、权限控制等核心功能<br>需要规划表结构与服务接口                |
| **api-gateway**    | 基础路由和鉴权搭建                     | 接口文档、限流、安全策略待完善                                    |

### 后续计划
| 任务阶段     | 任务内容                            | 目标                  | 时间预估  |
| -------- | ------------------------------- | ------------------- | ----- |
| **阶段 1** | 拆分 user & auth-service，定义清晰边界   | 独立鉴权服务，用户服务只做用户信息管理 | 1-2 天 |
| **阶段 2** | friend-service 完善<br>拉黑、验证、通知推送 | 实现完整好友管理和状态推送       | 2 天   |
| **阶段 3** | chat-service 优化<br>幂等、重试、群聊消息支持 | 消息可靠性和扩展性提升         | 2-3 天 |
| **阶段 4** | ws-gateway 优化<br>分布式连接池、Ack 路由  | 支持大规模在线用户，增强健壮性     | 1-2 天 |
| **阶段 5** | 开发 group-service 基础功能           | 群聊创建、成员管理、权限控制      | 3 天   |
| **阶段 6** | api-gateway 加强<br>接口文档、限流、鉴权策略  | 生产环境可用的统一入口         | 1 天   |
| **阶段 7** | 项目文档完善、部署方案设计                   | 易于维护和上线             | 1 天   |
