## 项目整体目录结构
    ✅ 采用 go-zero + 微服务架构
    ✅ 每个服务为独立 go-zero 工程
    ✅ 服务之间使用 gRPC 通信，统一入口由 API Gateway 提供 HTTP 接口
    ✅ 支持 Docker Compose 一键部署（包含 Kafka / Redis / MySQL / Etcd）

```   
im-backend/
├── api-gateway/               # go-zero API 接口网关（对外 HTTP）
│   └── etc/                   # 配置文件
│
├── ws-gateway/                # WebSocket 长连接网关（独立服务）
│   └── etc/
│
├── user-service/              # 用户注册 / 登录 / 信息查询
│   └── etc/
│
├── auth-service/              # JWT 签发 / 刷新 / 多端会话管理
│   └── etc/
│
├── friend-service/            # 好友增删 / 验证 / 通知
│   └── etc/
│
├── group-service/             # 群聊管理 / 成员管理 / 群功能控制
│   └── etc/
│
├── chat-service/              # 消息收发、Kafka 消费、离线消息
│   └── etc/
│
├── common/                    # 通用代码包（proto、工具函数、模型等）
│   ├── proto/                 # Protobuf 定义共享目录
│   ├── model/                 # GORM 模型
│   ├── utils/                 # 加密、token、日志等
│
├── deploy/                    # 部署文件夹
│   ├── docker-compose.yaml    # 一键部署入口
│   ├── Dockerfile             # 各服务对应 Dockerfile 示例
│   ├── kafka/                 # Kafka & Zookeeper 配置
│   ├── mysql/                 # 初始化 SQL 文件
│   └── etcd/                  # etcd 注册配置（可选）
│
├── scripts/                   # 启动脚本 / 初始化工具
├── go.mod
├── README.md
```
## 各模块启动前所需依赖项说明
| 模块               | 依赖项                    | 是否必须 | 说明                                |
| ---------------- | ---------------------- | ---- | --------------------------------- |
| `user-service`   | MySQL、Etcd             | ✅ 必须 | MySQL 存用户表，Etcd 注册服务用于 RPC        |
| `auth-service`   | Redis、Etcd             | ✅ 必须 | Redis 存 token/session，Etcd 用于服务发现 |
| `friend-service` | MySQL、Redis、Etcd       | ✅ 必须 | 关系存 MySQL，缓存好友列表用 Redis           |
| `chat-service`   | Kafka、Redis、MySQL、Etcd | ✅ 必须 | 消息生产/消费用 Kafka，Redis 缓存离线消息       |
| `group-service`  | MySQL、Redis、Etcd       | ✅ 必须 | 群聊信息在 MySQL，Etcd 注册 RPC           |
| `ws-gateway`     | Redis、auth-service RPC | ✅ 必须 | 校验用户在线状态 & 鉴权依赖 Redis + auth      |
| `api-gateway`    | 所有其他服务 gRPC 接口、Etcd    | ✅ 必须 | 作为网关必须能路由到各服务                     |
##  推荐环境准备（本地开发）
| 组件     | 推荐方式                    | 补充说明                    |
| ------ | ----------------------- | ----------------------- |
| Go 版本  | Go 1.21+                | 安装 `goctl` 脚手架工具        |
| 数据库    | MySQL 8                 | 本地或容器皆可                 |
| Redis  | Redis 6+                | 用于缓存 token、会话、在线状态      |
| Kafka  | kafka + zookeeper 容器    | 建议用 Docker Compose 一键启动 |
| Etcd   | 3.x 版本                  | 用于服务注册 / 发现             |
| Docker | Docker + Docker Compose | 本地快速启动服务依赖              |

## user-service
| 功能         | 目的                            |
| ---------- | ----------------------------- |
| 注册用户       | 插入新用户数据至 MySQL                |
| 用户登录（密码校验） | 返回 token（后续由 auth-service 实现） |
| 获取用户信息     | 根据 uid 查询用户                   |
| 用户列表/搜索    | 提供搜索或展示功能                     |

我们用 go-zero 提供的工具 goctl 来快速创建**服务骨架**。
编写user.proto，执行
```
goctl rpc protoc common/proto/user/user.proto \
  --go_out=./user-service \
  --go-grpc_out=./user-service \
  --zrpc_out=./user-service
```
go_out: proto生成的go代码所在的目录，proto本身的命令参数
go-grpc_out：proto生成的grpc代码所在的目录，proto本身的命令参数，和go_out必须同一个目录
zrpc_out： goctl rpc自带的命令，go-zero生成的代码所在的目录
执行成功后，user-service 下就会生成：
user.pb.go（自动生成）
user_grpc.pb.go
userrpc.go（注册服务用）
### 阶段总结
| 步骤    | 内容                                              | 是否完成 |
| ----- | ----------------------------------------------- | ---- |
| 🧱 1  | 用 `goctl` 生成了 `user-service` 骨架 ✅               | ✔️   |
| 📦 2  | 编写了 `user.proto` 并用 `goctl rpc protoc` 正确生成代码 ✅ | ✔️   |
| 🛠️ 3 | 配置并运行了 Docker 中的 MySQL 容器 ✅                     | ✔️   |
| 🔗 4  | 用 GORM 成功连接数据库并自动迁移 User 表 ✅                    | ✔️   |
| 🧹 5  | 把数据库配置解耦到了 `yaml` 配置文件 ✅                        | ✔️   |
| 🚀 6  | 成功运行 `user-service` 服务 ✅                        | ✔️   |
其中第一步完全没必要，第二部注意proto文件编写

### 阶段总结
我们已经完成了：
✅ 使用 Go-Zero 构建 user 微服务骨架
✅ 编写并生成 proto 文件（注册 & 查询接口）
✅ 使用 GORM 初始化数据库连接、自动建表
✅ 实现 Register 用户注册逻辑（密码加密 + 写入数据库）
✅ 实现 GetUser 查询逻辑（通过 UID 查用户名）

### 登陆逻辑
| 步骤  | 内容说明                                          |
| --- | --------------------------------------------- |
| 1️⃣ | 查询数据库，检查用户是否存在                                |
| 2️⃣ | 校验密码是否匹配（用 bcrypt 的 `CompareHashAndPassword`） |
| 3️⃣ | 签发 JWT token（这个我们会统一封装好）                      |
| 4️⃣ | 返回 token 给前端或调用方                              |


### 阶段总结
登录生成 JWT；
全局拦截器检查 token；
未携带 token 自动拒绝；
带上合法 token 正常访问
只是写了但是没验证能不能行，不想修改bug（脆弱哽咽

### GetProfile
| 步骤   | 内容                                     | 说明           |
| ---- | -------------------------------------- | ------------ |
| ✅ 1  | 用户发起 `GetProfile` 请求（携带 token）         | 用于鉴权         |
| ✅ 2  | gRPC 拦截器校验 token，将 UID 放入 context      | 已完成          |
| 🧩 3 | 在 `GetProfileLogic` 中，从 context 提取 UID | 不需要客户端传 uid  |
| 🧩 4 | 用 GORM 查库获取用户资料                        | username、头像等 |
| ✅ 5  | 返回给客户端                                 |              |

### 还可以优化的地方
如果你希望在拦截器中就把 UID 放到 context 中，可以自定义 context key，不过目前这个方案更直观
后面我们会为用户增加修改资料接口（nickname、签名、头像上传）
✅ 修改个人资料接口（UpdateProfile）
✅ 新增头像字段、性别、个性签名等（gorm 自动迁移）
✅ 实现前端需要的用户详情接口（多字段 + 安全脱敏）
咳嗨嗨，以后再说吧，这个go-zero把我害惨了

### 阶段总结
| 阶段      | 功能目标                    | 技术点                   |
| ------- | ----------------------- | --------------------- |
| ✅ 当前阶段  | 用户系统（注册 / 登录 / token鉴权） | gRPC、gorm、jwt         |
| 🚧 下阶段  | 好友系统（加好友 / 拉黑 / 列表）     | 多端关系表、状态码设计           |
| 🚧 后续阶段 | IM 通讯模块（消息发送、接收、存储）     | WebSocket、Redis、消息持久化 |
| 🚧 可选   | 用户在线状态、设备管理、消息已读        | 令牌刷新、WS心跳、设备识别        |

### Protobuf 代码的编写逻辑
确定版本：开头声明 syntax = "proto3";（推荐用 proto3）。
配置包名：根据业务模块定义 package（如用户模块用 user，订单模块用 order），并指定生成目标语言代码的路径（如 go_package）。
定义消息（数据结构）：
先想清楚接口需要的 “输入参数” 和 “输出结果”（如注册需要用户名密码，返回用户 ID）。
为每个字段指定类型和唯一编号（编号从 1 开始，不重复）。
定义服务（RPC 接口）：
一个服务对应一个业务模块（如 User 服务处理用户相关操作）。
每个 rpc 方法对应一个具体功能，格式为 rpc 方法名(请求消息) returns (响应消息);。

### 疑问
gRPC拦截器是什么，作用是什么？


---

## friend-service
### 基础功能
- 发送好友请求
- 查看好友请求列表
- 接受 / 拒绝好友请求
- 查看好友列表

1. 编写.proto文件
2. 生成friend-service项目框架
```
goctl rpc protoc common/proto/friend/friend.proto \
  --go_out=./friend-service \
  --go-grpc_out=./friend-service \
  --zrpc_out=./friend-service \
  --style=go_zero
```
3. 设计数据库表 (在svc中实现自动迁移，记得修改.yaml文件和config文件中的结构体)
4. 实现发送好友申请的接口逻辑
✅ 实现流程说明
    1. 功能目标
    用户 A 向用户 B 发送好友请求。后续 B 可以选择接受或拒绝。
    2. 步骤拆解
    检查是否已经存在相同的好友请求（避免重复发送）
    检查双方是否已经是好友（避免重复添加）
    插入一条新的好友请求记录（状态为 pending）
5. 查看收到的好友申请 （用户可以查看别人发给自己的所有好友请求。展示请求人信息）
6. 接受/拒绝好友申请
     用户可以接受或拒绝别人发来的好友请求；
     如果接受：更新请求状态为 accepted；在好友表中插入双方为好友的记录（双向关系）；
     如果拒绝：更新请求状态为 rejected；
     重复处理请求时不重复插入数据；
7. 获取好友列表 - 给定一个用户 ID，查出他的好友列表，返回好友的 ID 和用户名
8. 删除好友


---

## ws-gateway
🚪 ws-gateway 模块功能拆分
| 功能              | 说明                           |
| --------------- | ---------------------------- |
| 建立 WebSocket 连接 | 基于 token 验证身份后允许建立连接         |
| 用户在线状态管理        | 用户上下线状态在 Redis 中维护           |
| 长连接用户管理         | 基于内存或 Redis 管理连接 ID、用户 ID 映射 |
| 消息收发（直发）        | 接收消息并转发给目标用户（如果在线）           |
| 消息转 Kafka       | 如果对方不在线，消息投递到 Kafka，由后续服务处理  |

| 模块              | 功能目标描述                            |
| --------------- | --------------------------------- |
| 🧩 Gateway 网关服务 | 建立 WebSocket 长连接，支持 JWT 鉴权        |
| 🔐 用户认证         | 每个连接都带上 token，服务端完成 token 校验      |
| 📶 连接管理         | 每个用户可能有多个连接，管理用户连接列表并支持广播         |
| 📥 消息接收         | 接收客户端消息（发送给好友 / 群），转发到消息通道（Kafka） |
| 📤 消息推送         | 从 chat-service 拉取消息并下发到对应连接       |

技术选型建议：
使用 github.com/gorilla/websocket 建立连接
连接管理使用 map[userID][]conn 或 Redis 实现多端支持
消息体使用 JSON，结构统一
消息入库和离线投递交给 chat-service

推进顺序：
1. 初始化 ws-gateway 服务目录结构
2. 实现 WebSocket 连接建立逻辑
3. 集成 JWT 鉴权中间件
4. 构建连接管理器（Connection Manager）
5. 接收并转发消息到 chat-service
6. 接收 chat-service 推送回来的消息，并下发到连接

### 创建API文件
### 生成代码骨架
进入/ws-gateway目录，执行 goctl api go -api ./api/ws.api -dir .
### 实现/ws/connect接口
ws-gateway/internal/handler/connecthandler.go
升级为 WebSocket 连接并校验 Token
✅ 目标：
接收用户请求（token 通过 header 或 query 传）
鉴权 token，解析出 userId
将 HTTP 连接升级为 WebSocket 连接
将连接和 userId 绑定，加入连接管理器（稍后实现）

**当前已完成**
1. 服务骨架搭建
使用 goctl api 生成了 ws-gateway 的服务目录结构，包括 handler、logic、svc 等模块。
成功集成了 Gorilla WebSocket，具备 WebSocket 升级能力。

2. WebSocket 接入点 connectHandler
从 HTTP 请求中获取 token（支持 Header 或 Query 参数）。
使用封装好的 JWT 工具进行 token 验证。
提取出 userId。
成功将 HTTP 请求升级为 WebSocket 连接。

3. 连接交给逻辑层管理
编写了 HandleWebSocketConnection(svcCtx, userId, conn)，启动连接处理逻辑。
已实现心跳机制（定时发送 Ping），避免连接因空闲被断开。

4. 连接管理器（ConnManager）
在 svc.ServiceContext 中添加了全局连接管理器 ConnManager。
为每个 userId 维护对应的 WebSocket 连接，方便后续实现点对点消息转发。
支持添加连接、移除连接、通过 userId 获取连接。


### 搭建连接管理器
🔜 待开发功能列表（WebSocket 核心功能）
| 模块                   | 说明                                                        | 优先级  |
| -------------------- | --------------------------------------------------------- | ---- |
| 🧠 **ReadPump 读协程**  | 不断读取客户端消息，并解析为结构化命令（如发送聊天消息、心跳、加入群聊等）                     | ⭐⭐⭐⭐ |
| 🧠 **WritePump 写协程** | 把服务端发给客户端的消息写入 WebSocket 连接（如接收方收到聊天消息）                   | ⭐⭐⭐  |
| 🧼 **关闭清理**          | 客户端断开连接时，从 `ConnManager` 中移除对应连接，释放资源                     | ⭐⭐⭐⭐ |
| 💬 **消息格式设计**        | 定义统一的数据包结构，比如 `{type: "chat", to: 123, content: "hello"}` | ⭐⭐⭐⭐ |
| 🚀 **点对点消息转发**       | 根据消息目标用户 ID，调用 `ConnManager` 获取目标连接，进行消息转发                | ⭐⭐⭐⭐ |
| 📦 **离线消息队列（可选）**    | 若目标用户不在线，将消息暂存到 Redis/MySQL 等                             | ⭐⭐   |
| 📢 **广播/群聊支持（可选）**   | 给多个用户推送消息，比如群聊/系统通知                                       | ⭐⭐   |
| 🔐 **封禁/黑名单机制（可选）**  | 限制某些用户连接或通信                                               | ⭐    |

### 实现readpump，接受客户端发来的消息
ReadPump 是啥？
我们要在一个 goroutine 中不停监听这个连接的输入（read loop），一旦客户端通过 WebSocket 发来消息，我们就能拿到数据。
我们规定所有客户端发来的消息必须是json格式，例如：
```
{
  "type": "chat",
  "to": 1002,
  "content": "hello"
}
```

### 疑问
为什么要有connect.go和connectlogic.go两个文件？是什么作用？
| 文件名               | 路径               | 用途                                     |
| ----------------- | ---------------- | -------------------------------------- |
| `connectlogic.go` | `internal/logic` | 是 go-zero 框架**自动生成的 REST 接口处理逻辑层**     |
| `connect.go`      | `internal/logic` | 是你自己手动写的 **WebSocket 长连接处理逻辑（非 REST）** |
为什么它们是分开的？
这是因为：
🧩 connectlogic.go（自动生成的）
这是 go-zero 的传统做法，主要用于：
处理 HTTP 请求
从 controller 层接收 req *types.ConnectReq
返回 resp *types.ConnectResp
属于 RESTful API 风格的业务
简单来说，这是给 rest.RegisterHandlers() 绑定的 handler 用的，和传统 HTTP 路由是一套体系。

🔌 connect.go（你自己手动加的）
这个是WebSocket 长连接逻辑的核心处理部分：
没有使用 go-zero 自动生成结构
WebSocket 是一种 状态连接/事件驱动的通信方式
和 HTTP 一请求一响应完全不同
所以要自己实现 HandleWebSocketConnection 等连接生命周期管理函数
它不是给 HTTP handler 用的，而是给升级成功后的连接用的「真正的通信逻辑处理器」。

| 项目           | `connectlogic.go`     | `connect.go`                |
| ------------ | --------------------- | --------------------------- |
| 用于什么         | 处理 HTTP 请求（RESTful）   | 管理 WebSocket 连接生命周期         |
| 谁调用它         | go-zero 自动注册的 HTTP 路由 | 升级 WebSocket 后你自己写的 handler |
| 是否需要 context | ✅ 有 REST context      | ❌ 用不到 context               |
| 是否状态化连接      | ❌ 一次请求一次响应            | ✅ 长连接、心跳、读写                 |
| 文件来源         | `goctl api` 生成        | 手动创建                        |

### 做短线重连、清理、心跳