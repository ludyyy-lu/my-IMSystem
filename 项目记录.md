## 项目整体目录结构
    ✅ 采用 go-zero + 微服务架构
    ✅ 每个服务为独立 go-zero 工程
    ✅ 服务之间使用 gRPC 通信，统一入口由 API Gateway 提供 HTTP 接口
    ✅ 支持 Docker Compose 一键部署（包含 Kafka / Redis / MySQL / Etcd）

```   
im-backend/
├── api-gateway/               # go-zero API 接口网关（对外 HTTP）
│   └── etc/                   # 配置文件
│
├── ws-gateway/                # WebSocket 长连接网关（独立服务）
│   └── etc/
│
├── user-service/              # 用户注册 / 登录 / 信息查询
│   └── etc/
│
├── auth-service/              # JWT 签发 / 刷新 / 多端会话管理
│   └── etc/
│
├── friend-service/            # 好友增删 / 验证 / 通知
│   └── etc/
│
├── group-service/             # 群聊管理 / 成员管理 / 群功能控制
│   └── etc/
│
├── chat-service/              # 消息收发、Kafka 消费、离线消息
│   └── etc/
│
├── common/                    # 通用代码包（proto、工具函数、模型等）
│   ├── proto/                 # Protobuf 定义共享目录
│   ├── model/                 # GORM 模型
│   ├── utils/                 # 加密、token、日志等
│
├── deploy/                    # 部署文件夹
│   ├── docker-compose.yaml    # 一键部署入口
│   ├── Dockerfile             # 各服务对应 Dockerfile 示例
│   ├── kafka/                 # Kafka & Zookeeper 配置
│   ├── mysql/                 # 初始化 SQL 文件
│   └── etcd/                  # etcd 注册配置（可选）
│
├── scripts/                   # 启动脚本 / 初始化工具
├── go.mod
├── README.md
```
## 各模块启动前所需依赖项说明
| 模块               | 依赖项                    | 是否必须 | 说明                                |
| ---------------- | ---------------------- | ---- | --------------------------------- |
| `user-service`   | MySQL、Etcd             | ✅ 必须 | MySQL 存用户表，Etcd 注册服务用于 RPC        |
| `auth-service`   | Redis、Etcd             | ✅ 必须 | Redis 存 token/session，Etcd 用于服务发现 |
| `friend-service` | MySQL、Redis、Etcd       | ✅ 必须 | 关系存 MySQL，缓存好友列表用 Redis           |
| `chat-service`   | Kafka、Redis、MySQL、Etcd | ✅ 必须 | 消息生产/消费用 Kafka，Redis 缓存离线消息       |
| `group-service`  | MySQL、Redis、Etcd       | ✅ 必须 | 群聊信息在 MySQL，Etcd 注册 RPC           |
| `ws-gateway`     | Redis、auth-service RPC | ✅ 必须 | 校验用户在线状态 & 鉴权依赖 Redis + auth      |
| `api-gateway`    | 所有其他服务 gRPC 接口、Etcd    | ✅ 必须 | 作为网关必须能路由到各服务                     |
##  推荐环境准备（本地开发）
| 组件     | 推荐方式                    | 补充说明                    |
| ------ | ----------------------- | ----------------------- |
| Go 版本  | Go 1.21+                | 安装 `goctl` 脚手架工具        |
| 数据库    | MySQL 8                 | 本地或容器皆可                 |
| Redis  | Redis 6+                | 用于缓存 token、会话、在线状态      |
| Kafka  | kafka + zookeeper 容器    | 建议用 Docker Compose 一键启动 |
| Etcd   | 3.x 版本                  | 用于服务注册 / 发现             |
| Docker | Docker + Docker Compose | 本地快速启动服务依赖              |

## user-service
| 功能         | 目的                            |
| ---------- | ----------------------------- |
| 注册用户       | 插入新用户数据至 MySQL                |
| 用户登录（密码校验） | 返回 token（后续由 auth-service 实现） |
| 获取用户信息     | 根据 uid 查询用户                   |
| 用户列表/搜索    | 提供搜索或展示功能                     |

我们用 go-zero 提供的工具 goctl 来快速创建**服务骨架**。
编写user.proto，执行
```
goctl rpc protoc common/proto/user/user.proto \
  --go_out=./user-service \
  --go-grpc_out=./user-service \
  --zrpc_out=./user-service
```
go_out: proto生成的go代码所在的目录，proto本身的命令参数
go-grpc_out：proto生成的grpc代码所在的目录，proto本身的命令参数，和go_out必须同一个目录
zrpc_out： goctl rpc自带的命令，go-zero生成的代码所在的目录
执行成功后，user-service 下就会生成：
user.pb.go（自动生成）
user_grpc.pb.go
userrpc.go（注册服务用）
### 阶段总结
| 步骤    | 内容                                              | 是否完成 |
| ----- | ----------------------------------------------- | ---- |
| 🧱 1  | 用 `goctl` 生成了 `user-service` 骨架 ✅               | ✔️   |
| 📦 2  | 编写了 `user.proto` 并用 `goctl rpc protoc` 正确生成代码 ✅ | ✔️   |
| 🛠️ 3 | 配置并运行了 Docker 中的 MySQL 容器 ✅                     | ✔️   |
| 🔗 4  | 用 GORM 成功连接数据库并自动迁移 User 表 ✅                    | ✔️   |
| 🧹 5  | 把数据库配置解耦到了 `yaml` 配置文件 ✅                        | ✔️   |
| 🚀 6  | 成功运行 `user-service` 服务 ✅                        | ✔️   |
其中第一步完全没必要，第二部注意proto文件编写

### 阶段总结
我们已经完成了：
✅ 使用 Go-Zero 构建 user 微服务骨架
✅ 编写并生成 proto 文件（注册 & 查询接口）
✅ 使用 GORM 初始化数据库连接、自动建表
✅ 实现 Register 用户注册逻辑（密码加密 + 写入数据库）
✅ 实现 GetUser 查询逻辑（通过 UID 查用户名）

### 登陆逻辑
| 步骤  | 内容说明                                          |
| --- | --------------------------------------------- |
| 1️⃣ | 查询数据库，检查用户是否存在                                |
| 2️⃣ | 校验密码是否匹配（用 bcrypt 的 `CompareHashAndPassword`） |
| 3️⃣ | 签发 JWT token（这个我们会统一封装好）                      |
| 4️⃣ | 返回 token 给前端或调用方                              |


### 阶段总结
登录生成 JWT；
全局拦截器检查 token；
未携带 token 自动拒绝；
带上合法 token 正常访问
只是写了但是没验证能不能行，不想修改bug（脆弱哽咽

### GetProfile
| 步骤   | 内容                                     | 说明           |
| ---- | -------------------------------------- | ------------ |
| ✅ 1  | 用户发起 `GetProfile` 请求（携带 token）         | 用于鉴权         |
| ✅ 2  | gRPC 拦截器校验 token，将 UID 放入 context      | 已完成          |
| 🧩 3 | 在 `GetProfileLogic` 中，从 context 提取 UID | 不需要客户端传 uid  |
| 🧩 4 | 用 GORM 查库获取用户资料                        | username、头像等 |
| ✅ 5  | 返回给客户端                                 |              |

### 还可以优化的地方
如果你希望在拦截器中就把 UID 放到 context 中，可以自定义 context key，不过目前这个方案更直观
后面我们会为用户增加修改资料接口（nickname、签名、头像上传）
咳嗨嗨，以后再说吧，这个go-zero把我害惨了

### Protobuf 代码的编写逻辑
确定版本：开头声明 syntax = "proto3";（推荐用 proto3）。
配置包名：根据业务模块定义 package（如用户模块用 user，订单模块用 order），并指定生成目标语言代码的路径（如 go_package）。
定义消息（数据结构）：
先想清楚接口需要的 “输入参数” 和 “输出结果”（如注册需要用户名密码，返回用户 ID）。
为每个字段指定类型和唯一编号（编号从 1 开始，不重复）。
定义服务（RPC 接口）：
一个服务对应一个业务模块（如 User 服务处理用户相关操作）。
每个 rpc 方法对应一个具体功能，格式为 rpc 方法名(请求消息) returns (响应消息);。

### 疑问
gRPC拦截器是什么，作用是什么？
